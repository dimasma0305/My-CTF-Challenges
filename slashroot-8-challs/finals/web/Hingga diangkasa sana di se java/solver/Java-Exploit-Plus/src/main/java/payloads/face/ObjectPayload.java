package payloads.face;

import org.reflections.Reflections;

import util.PayloadClassInfo;

import java.io.IOException;
import java.lang.annotation.Annotation;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

@SuppressWarnings("rawtypes")
public interface ObjectPayload<T> {

    /*
     * return armed payload object to be serialized that will execute specified
     * command on deserialization
     */
    public T getObject(String command) throws Exception;

    public static class Utils {

        // get payload classes by classpath scanning
        public static Set<Class<? extends ObjectPayload>> getPayloadClasses() {
            final Reflections reflections = new Reflections(ObjectPayload.class.getPackage().getName());
            final Set<Class<? extends ObjectPayload>> payloadTypes = reflections.getSubTypesOf(ObjectPayload.class);
            for (Iterator<Class<? extends ObjectPayload>> iterator = payloadTypes.iterator(); iterator.hasNext();) {
                Class<? extends ObjectPayload> pc = iterator.next();
                if (pc.isInterface() || Modifier.isAbstract(pc.getModifiers())) {
                    iterator.remove();
                }
            }
            return payloadTypes;
        }

        @SuppressWarnings("unchecked")
        public static Class<? extends ObjectPayload> getPayloadClass(final String className) {
            Class<? extends ObjectPayload> clazz = null;
            try {
                clazz = (Class<? extends ObjectPayload>) Class.forName(className);
            } catch (Exception e1) {
            }
            if (clazz == null) {
                try {
                    return clazz = (Class<? extends ObjectPayload>) Class
                            .forName(className);
                } catch (Exception e2) {
                }
            }
            if (clazz != null && !ObjectPayload.class.isAssignableFrom(clazz)) {
                clazz = null;
            }
            return clazz;
        }

        public static Object makePayloadObject(String payloadType, String payloadArg) {
            final Class<? extends ObjectPayload> payloadClass = getPayloadClass(payloadType);
            if (payloadClass == null || !ObjectPayload.class.isAssignableFrom(payloadClass)) {
                throw new IllegalArgumentException("Invalid payload type '" + payloadType + "'");

            }

            final Object payloadObject;
            try {
                final ObjectPayload payload = payloadClass.newInstance();
                payloadObject = payload.getObject(payloadArg);
            } catch (Exception e) {
                throw new IllegalArgumentException("Failed to construct payload", e);
            }
            return payloadObject;
        }

        @SuppressWarnings("unchecked")
        public static void releasePayload(ObjectPayload payload, Object object) throws Exception {
            if (payload instanceof ReleaseableObjectPayload) {
                ((ReleaseableObjectPayload) payload).release(object);
            }
        }

        public static void releasePayload(String payloadType, Object payloadObject) {
            final Class<? extends ObjectPayload> payloadClass = getPayloadClass(payloadType);
            if (payloadClass == null || !ObjectPayload.class.isAssignableFrom(payloadClass)) {
                throw new IllegalArgumentException("Invalid payload type '" + payloadType + "'");

            }

            try {
                final ObjectPayload payload = payloadClass.newInstance();
                releasePayload(payload, payloadObject);
            } catch (Exception e) {
                e.printStackTrace();
            }

        }
    }

    static List<Class<?>> getClasses(String packageName) throws IOException, ClassNotFoundException {
        List<Class<?>> classes = new ArrayList<>();
        Reflections reflections = new Reflections(packageName);
        Set<Class<? extends ObjectPayload>> subTypes = reflections.getSubTypesOf(ObjectPayload.class);
        for (Class<? extends ObjectPayload> subType : subTypes) {
            classes.add(subType);
        }
        return classes;
    }


    public static List<PayloadClassInfo> getPayloadClassInfo(String path) {
        List<PayloadClassInfo> classInfos = new ArrayList<>();
        try {
            List<Class<?>> classes = getClasses(path);
            for (Class<?> clazz : classes) {
                PayloadClassInfo classInfo = new PayloadClassInfo();

                // Check if the Authors annotation exists
                Annotation authorsAnnotation = clazz.getAnnotation(payloads.annotation.Authors.class);
                if (authorsAnnotation != null) {
                    String[] authorAnnotationValues = ((payloads.annotation.Authors) authorsAnnotation).value();
                    if (authorAnnotationValues.length > 0) {
                        classInfo.setAuthor(authorAnnotationValues[0]);
                    }
                }

                // Check if the Dependencies annotation exists
                Annotation dependenciesAnnotation = clazz.getAnnotation(payloads.annotation.Dependencies.class);
                if (dependenciesAnnotation != null) {
                    String[] depsAnnotationValues = ((payloads.annotation.Dependencies) dependenciesAnnotation).value();
                    if (depsAnnotationValues.length > 0) {
                        classInfo.setDependencies(depsAnnotationValues[0]);
                    }
                }
                String[] className = clazz.getName().split("\\.");
                classInfo.setClassName(className[className.length - 1]);
                classInfos.add(classInfo);
            }
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
        return classInfos;
    }
}
